%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plantilla de memoria en LaTeX para la ETSIT - Universidad Rey Juan Carlos
%%
%% Por Gregorio Robles <grex arroba gsyc.urjc.es>
%%     Grupo de Sistemas y Comunicaciones
%%     Escuela Técnica Superior de Ingenieros de Telecomunicación
%%     Universidad Rey Juan Carlos
%% (muchas ideas tomadas de Internet, colegas del GSyC, antiguos alumnos...
%%  etc. Muchas gracias a todos)
%%
%% La última versión de esta plantilla está siempre disponible en:
%%     https://github.com/gregoriorobles/plantilla-memoria
%%
%% Para obtener PDF, ejecuta en la shell:
%%   make
%% (las imágenes deben ir en PNG o JPG)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper, 12pt]{book}
%\usepackage[T1]{fontenc}

\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry}
\usepackage{times}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel} % Comenta esta línea si tu memoria es en inglés
\usepackage{url}
%\usepackage[dvipdfm]{graphicx}
\usepackage{graphicx}
\usepackage{float}  %% H para posicionar figuras
\usepackage[nottoc, notlot, notlof, notindex]{tocbibind} %% Opciones de índice
\usepackage{latexsym}  %% Logo LaTeX
\usepackage{amsmath}

\title{Memoria del Proyecto}
\author{Carmen González López}

\renewcommand{\baselinestretch}{1.5}  %% Interlineado

\begin{document}

\renewcommand{\refname}{Bibliografía}  %% Renombrando
\renewcommand{\appendixname}{Apéndice}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PORTADA

\begin{titlepage}
\begin{center}
\includegraphics[scale=0.8]{img/URJ_logo_Color_POS.png}

\vspace{1.75cm}

\Large
GRADO EN INGENIERÍA EN SISTEMAS AUDIOVISUALES Y MULTIMEDIA

\vspace{0.4cm}

\large
Curso Académico 2022/2023

\vspace{0.8cm}

Trabajo Fin de Grado/Máster

\vspace{2.5cm}

\LARGE
TÍTULO DEL TRABAJO EN MAYÚSCULAS

\vspace{4cm}

\large
Autor : Carmen González López \\
Tutor : Gregorio Robles Martínez
\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty} % para que no se numere esta pagina


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Para firmar
\clearpage
\pagenumbering{gobble}
\chapter*{}

\vspace{-4cm}
\begin{center}
\LARGE
\textbf{Trabajo Fin de Grado/Máster}

\vspace{1cm}
\large
Título del Trabajo con Letras Capitales para Sustantivos y Adjetivos

\vspace{1cm}
\large
\textbf{Autor :} Carmen González López\\
\textbf{Tutor :} Gregorio Robles Martínez

\end{center}

\vspace{1cm}
La defensa del presente Proyecto Fin de Carrera se realizó el día \qquad$\;\,$ de \qquad\qquad\qquad\qquad \newline de 202X, siendo calificada por el siguiente tribunal:


\vspace{0.5cm}
\textbf{Presidente:}

\vspace{1.2cm}
\textbf{Secretario:}

\vspace{1.2cm}
\textbf{Vocal:}


\vspace{1.2cm}
y habiendo obtenido la siguiente calificación:

\vspace{1cm}
\textbf{Calificación:}


\vspace{1cm}
\begin{flushright}
Fuenlabrada, a \qquad$\;\,$ de \qquad\qquad\qquad\qquad de 202X
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Dedicatoria

\chapter*{}
\pagenumbering{Roman} % para comenzar la numeracion de paginas en numeros romanos
\begin{flushright}
\textit{Dedicado a \\
mi familia y amigos}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Agradecimientos

\chapter*{Agradecimientos}
%\addcontentsline{toc}{chapter}{Agradecimientos} % si queremos que aparezca en el índice
\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado 

Aquí vienen los agradecimientos\ldots Aunque está bien acordarse de la pareja, no hay que olvidarse de dar las gracias a tu madre, que aunque a veces no lo parezca disfrutará tanto de tus logros como tú\ldots 
Además, la pareja quizás no sea para siempre, pero tu madre sí.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen

\chapter*{Resumen}
%\addcontentsline{toc}{chapter}{Resumen} % si queremos que aparezca en el índice
\markboth{RESUMEN}{RESUMEN} % encabezado


Aquí viene un resumen del proyecto.
Ha de constar de tres o cuatro párrafos, donde se presente de manera clara y concisa de qué va el proyecto. 
Han de quedar respondidas las siguientes preguntas:

\begin{itemize}
  \item ¿De qué va este proyecto? ¿Cuál es su objetivo principal?
  \item ¿Cómo se ha realizado? ¿Qué tecnologías están involucradas?
  \item ¿En qué contexto se ha realizado el proyecto? ¿Es un proyecto dentro de un marco general?
\end{itemize}

Lo mejor es escribir el resumen al final.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen en inglés

\chapter*{Summary}
%\addcontentsline{toc}{chapter}{Summary} % si queremos que aparezca en el índice
\markboth{SUMMARY}{SUMMARY} % encabezado

Here comes a translation of the ``Resumen'' into English. 
Please, double check it for correct grammar and spelling.
As it is the translation of the ``Resumen'', which is supposed to be written at the end, this as well should be filled out just before submitting.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ÍNDICES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Las buenas noticias es que los índices se generan automáticamente.
% Lo único que tienes que hacer es elegir cuáles quieren que se generen,
% y comentar/descomentar esa instrucción de LaTeX.

%%%% Índice de contenidos
\tableofcontents 
%%%% Índice de figuras
\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de figuras} % para que aparezca en el indice de contenidos
\listoffigures % indice de figuras
%%%% Índice de tablas
%\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de tablas} % para que aparezca en el indice de contenidos
%\listoftables % indice de tablas


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCCIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Introducción}
\label{chap:introducción}
\label{sec:intro} % etiqueta para poder referenciar luego en el texto con ~\ref{sec:intro}
\pagenumbering{arabic} % para empezar la numeración de página con números

En este capítulo se introduce el proyecto.
Debería tener información general sobre el mismo, dando la información sobre el contexto en el que se ha desarrollado.

No te olvides de echarle un ojo a la página con los cinco errores de escritura más frecuentes\footnote{\url{http://www.tallerdeescritores.com/errores-de-escritura-frecuentes}}.

Aconsejo a todo el mundo que mire y se inspire en memorias pasadas.
Las memorias de los proyectos que he llevado yo están (casi) todas almacenadas en mi web del GSyC\footnote{\url{https://gsyc.urjc.es/~grex/pfcs/}}.


\section{Estructura de la memoria}
\label{sec:estructura}

Describiremos la estructura de la memoria, exponiendo el contenido de cada uno de los capítulos, proporcionando así una guía organizada del trabajo de fin de grado para una mejor lectura y comprensión de este.

\begin{itemize}
  
  \item \textbf{Capítulo ~\ref{chap:introducción}: Introducción.} 

  \item \textbf{Capítulo~\ref{chap:objetivos}: Objetivos.} En esta sección se establece el objetivo general que se pretende alcanzar con este proyecto. 
  Así como los objetivos específicos necesarios que van a guiar nuestro proyecto y la planificación de dichos objetivos(de todo el proyecto). 
  
  \item \textbf{Capítulo~\ref{chap:estado}: Estado del arte.} En esta sección se proporciona información detallada sobre el diseño, las características y los usos de cada una de las tecnologías usadas en el proyecto.  
  
  \item \textbf{Capítulo ~\ref{chap:diseño}: Diseño e implementación.} En esta sección se detallan las fases que se han llevado a cabo para realizar el análisis de estudio. 
  También se describe la arquitectura general del proyecto, los procedimientos utilizados para la recolección y el almacenamiento de los datos y la descripción del análisis de los datos.
  %  Discusión de las limitaciones del diseño e implementación??

  \item \textbf{Capítulo ~\ref{chap:experimentos}: Experimentos y validación.}

  \item \textbf{Capítulo ~\ref{chap:resultados}: Resultados.} En esta sección se realiza una descripción detallada de los datos recopilados, de los análisis estadísticos realizados, de los resultados obtenidos en el análisis y ; además, se realiza una conclusión de dichos resultados.
 
  \item \textbf{Capítulo~\ref{chap:conclusiones}: Conclusiones.} En esta sección se presenta un resumen de los resultados obtenidos y de las conclusiones a las que se ha llegado. 
  También se enumeran los conocimientos adquiridos durante la carrera que se han aplicado en este proyecto y los aprendidos durante la realización de este.
  Por último, se comentan futuros trabajos o mejoras para el estudio de los desarrolladores que utilizan archivos UML. 
  
  
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBJETIVOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar
\chapter{Objetivos} % título del capítulo (se muestra)
\label{chap:objetivos} % identificador del capítulo (no se muestra, es para poder referenciarlo)

En un trabajo de fin de grado es muy importante describir el propósito final del proyecto, definir cuáles serán los aspectos a tratar, así como la planificación llevada a cabo.
Todo esto ayudará a los lectores a hacer un seguimiento del proyecto. 
En este capítulo, se presentan los objetivos del trabajo de fin de grado y los procedimientos planteados para lograrlos.


\section{Objetivo general} % título de sección (se muestra)
\label{sec:objetivo-general} % identificador de sección (no se muestra, es para poder referenciarla)

El objetivo general de este Trabajo Fin de Grado consiste en analizar repositorios de la plataforma de Github para observar las diferencias y similitudes que existen entre los desarrolladores que usan ficheros UML frente al resto de desarrolladores.

\section{Objetivos específicos}
\label{sec:objetivos-especificos}

% Los objetivos específicos se pueden entender como las tareas en las que se ha desglosado el objetivo general.
% relacionados con el planteamiento del problema y el marco teórico, ya que deben responder a las preguntas que se han planteado en la introducción y estar basados en la revisión bibliográfica previa.
% sección crucial para establecer la dirección y los objetivos específicos de la investigación o proyecto, lo que permitirá guiar el trabajo y evaluar su éxito en la consecución de los mismos.
Para lograr el objetivo general de este proyecto se han establecido los siguientes objetivos específicos:

\begin{itemize}
  \item Estudiar y probar el funcionamiento de Perceval
  \item Seleccionar una serie de repositorios de GitHub y almacenarlos en una estructura JSON.
  \item Observar los datos amacenados en los archivos JSON obtenidos e identificar los datos que son de interés para comparar en nuestro estudio.
  \item Desarrollar los programas de extracción y almacenamiento de los datos escogidos en MongoDB.  
  \item Realizar el análisis de los resultados obtenidos para determinar las similitudes y diferencias más relevantes entre los desarrolladores que usan UML y los que no.
\end{itemize}


\section{Planificación temporal}
\label{sec:planificacion-temporal}

% A mí me gusta que aquí pongáis una descripción de lo que os ha llevado realizar el trabajo. Hay gente que añade un diagrama de GANTT.
% Lo importante es que quede claro cuánto tiempo llevas (tiempo natural, p.ej., 6 meses) y a qué nivel de esfuerzo (p.ej., principalmente los fines de semana).

% (EL 26 de ABRIL DEL AÑO PASADO ABANDONÉ EL OTRO TFG) [LOS DESARROLLADORES QUE TOCAN UML SON DIFERENTES DEL RESTO]
% [Como respondería a la pregunta y ver que información podría conseguir -- ¿LOS QUE TOCAN UML, TOCAN OTROS TIPOS DE FICHEROS?, ¿ES EL QUE MÁS COMMIT HACE? ¿HACE MENOS COMMITS? ¿HACE DOCUMENTACIÓN? ]
% [26 abril- 27 de junio documentación perceval, base de datos y pensar en los puntos a analizar de un repositorio ]
% ( en mayo y junio se me juntaron las últimas entregas de trabajos y exámenes 22/6/22)
% [27 junio - 27 julio]
% [27 julio- 16 septiembre]
% [ 16 septiembre -16 de diciembre]
% [16 diciembre - 6 febrero]
% [6 febrero -28 febrero empezar a escribir la memoria]


A finales de abril del año pasado empecé mi proyecto de fin de grado. 
El desarrollo de este trabajo comenzó en mayo de 2022, cuando el profesor Gregorio Robles Martínez me sugirió la idea del proyecto que he llevado a cabo. 


Durante los meses de mayo y junio empecé a documentarme sobre Lindholmen dataset\footnote{\url{http://models-db.com/}}, que es una base de datos con los repositorios que utilizan diagramas UML en GitHub.
De la misma manera, obtuve la información necesaria sobre las herramientas Grimoire Perceval\footnote{\url{https://github.com/chaoss/grimoirelab-perceval}} y GitHub API\footnote{\url{https://docs.github.com/es/rest}}, las cuales se utilizan para analizar repositorios y extraer datos de estos. 
Después del estudio y análisis de estas herramientas, me decanté por Perceval, ya que con ella se obtienen más datos de Github.


De julio a septiembre, empecé a descargar y almacenar en MongoDB algunos de los repositorios obtenidos en Lindholmen dataset usando Perceval para ver qué datos se obtenían y cuales eran más relevantes para, posteriormente, realizar el análisis.
También, inicié el desarrollo de varios programas con los que extaer los datos de interés que, previamente, había seleccionado.


Desde octubre hasta diciembre estuve desarrollando un programa que guardase todos los datos de interés extraídos en MongoDB y otro programa que analizase dichos datos almacenados en MongoDB.
A la vez, fui recopilando y almacenando los datos de una serie de repositorios de desarrolladores en los que hay archivos UML y repositorios en los que no hay archivos UML.
Además, almacené los commits de dichos repositorios; ya que estos contienen información de interés para el desarrollo de nuestro análisis.


Durante los meses de enero y febrero del 2023, busqué cómo introducir los archivos JSON obtenidos, tanto de los repositorios, como de los commits en MongoDB de forma automática, que hasta ese momento había hecho de manera manual.
Esto supuso una mejora en el proceso de desarrollo del proyecto, ya que aceleró la introducción en MongoDB de los datos necesarios para el posterior análisis.
Para ello, decidí crear un programa que ejecutase el proceso de mongoimport de cada uno de los archivos que había descargado. 


(Entre marzo y abril, inicié el proceso de escritura de la memoria del proyecto...)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ESTADO DEL ARTE %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Estado del arte}
\label{chap:estado}

En este apartado, se proporciona una comprensión completa y actualizada de las herramientas y librerías usadas en el Trabajo Fin de Grado.
Esta exposición nos da una visión de la metodología empleada a lo largo de todo el proyecto.

\section{Tecnologías y herramientas} % título de sección (se muestra)
\label{sec:tecnologías y herramienta}

\subsection{Github} % título de sección (se muestra)
\label{sec:github} % identificador de sección (no se muestra, es para poder referenciarla)

Github es una plataforma web de desarrollo colaborativo de software\footnote{\url{https://github.com/}} que permite la colaboración y el almacenamiento de proyectos de código abierto o cerrado.
En esta plataforma, los usuarios pueden crear y unirse a proyectos para compartir ideas, discutir posibles soluciones y colaborar entre ellos para mejorar dichos proyecto.
La función principal de Github~\cite{astigarraga2022se} es que los usuarios puedan trabajar juntos en un proyecto desde cualquier lugar y en cualquier momento, ya que, registra el desarrollo de los proyectos de forma remota en la nube y no requiere de una infraestructura de hardware específica.
Github ofrece una serie de bibliotecas para ayudar a los desarrolladores en su trabajo y herramientas para la gestión de versiones del software, la gestión de problemas, la revisión de código, etc. 
Github integra la funcionalidad de Git que es un sistema de control de versiones distribuido.
Se dice que es ``distribuido'' porque git tiene un historial completo de cambios, en el cual se pueden revisar los cambios realizados en el código a lo largo del tiempo. 
Esto permite ver las modificaciones de cada desarrollador e incluso deshacerlas si es necesario. Además permite el trabajo de varios desarrolladores en un mismo proyecto.
En resumen, GitHub es una plataforma que se ha convertido en una herramienta muy popular y esencial en la comunidad de desarrollo de software, ya que permite colaborar y trabajar en equipo para crear proyectos de alta calidad.
 

\subsection{Mongodb} % título de sección (se muestra)
\label{sec:mongodb} % identificador de sección (no se muestra, es para poder referenciarla)

MongoDB\footnote{\url{https://www.mongodb.com/}} es un sistema de gestión de bases de datos no relacional (NoSQL) de código abierto. 
MongoDB ha sido diseñado para almacenar grandes volúmenes de datos; estos datos se almacenan y recuperan en formato BJSON \footnote{\url{https://www.mongodb.com/json-and-bson}} (Binary JSON), en lugar de en un formato de tabla relacional.
El formato BJSON se inventó para solucionar algunos problemas que hacen que usar el formato de representación de objetos JSON no sea la mejor opción dentro de una base de datos. 
Con BJSON se optimiza la velocidad, el espacio y se mejora la eficiencia; solucionando así los problemas que tiene JSON de carecer de soporte para fechas y datos binarios y de no tener una longitud fija para los objetos y las propiedades JSON.
En definitiva, MongoDB es un modelo de base de datos orientado a documentos. Cuando se almacena un documento a éste se le asigna un código que facilita el manejo de los datos que contiene.


MongoDB\footnote{\url{https://www.mongodb.com/es/nosql-explained}} tiene un modelo avanzado de consultas e idexación.               
A esto hay que añadir que cuenta con una alta disponibilidad gracias a sus sistemas en la nube y por tanto es capaz de recuperarse en caso de fallo. 
Esta recuperación se consigue mediante el proceso de replicación automática.
La consultas se ejecutan de la siguiente manera: MongoDB recibe por defecto al nodo (index) primario todas las lecturas y ejecuta todas las escrituras.
El proceso de replicación permite tener siempre una copia exacta del nodo primario, al replicar sus datos en los nodos secundarios.
En el caso de que se produzca un fallo en el sistema, el nodo primario pasaría a ser uno de los secundarios contribuyendo a la recuperación del sistema. 
Otro proceso con el que cuenta es el fragmentación automática (auto-sharding) y el escalado horizontal que permiten la distribución de datos en múltiples servidores de forma que si uno falla, se sustituye rápidamente por otro servidor.
MongoDB también ofrece controles de seguridad integrados para todos los datos.


Por último, MongoDB se puede ejecutar en una variedad de plataformas y sistemas operativos, y es compatible con muchos lenguajes de programación.
Por ello es utilizado en una amplia variedad de aplicaciones, incluyendo aplicaciones web, aplicaciones móviles, juegos y análisis de datos, entre otros.


\subsection{JSON} % título de sección (se muestra)
\label{sec:json} % identificador de sección (no se muestra, es para poder referenciarla)

JSON\footnote{\url{https://www.json.org/json-es.html}} (JavaScript Object Notation) es un formato ligero de intercambio de datos que se utiliza para transmitir y almacenar datos estructurados. 
Fue diseñado con el objetivo de que fuese un formato de texto portátil, mínimo y, originalmente, para ser utilizado con JavaScript. 
JSON es una colección no ordenada de pares clave-valor separados por comas y encerrados en llaves que se puede estructurar como un array o como un objeto~\cite{bray2014javascript}. 
En este proyecto usaremos la estructura JSON de objeto como podemos ver en la figura ~\ref{fig:json}. 


En el siguiente objeto JSON tenemos dos pares clave-valor entre \{ \} y separados por una coma; en los cuales las claves tiene como valor las cadenas ``string1'' y ``string2'' \{``key1'': ``string1'', ``key2'' : ``string2''\}. 
Cada clave es una cadena de caracteres que se identifica con un valor correspondiente; estos valores pueden ser de cualquier tipo de datos: números, cadenas, booleanos, objetos y matrices.
Una de las principales ventajas de JSON es que es fácil de leer y escribir para los humanos, lo que lo hace más fácil de entender y depurar en caso de problemas. 
Este tipo de estructuras son universales y por eso JSON es compatible con la mayoría de los lenguajes de programación y se ha convertido en un formato de datos muy popular.
Por esta razón, al ser tan versátil, se utiliza en aplicaciones web y móviles para transmitir datos entre el cliente y el servidor y como formato para el almacenamiento en bases de datos NoSQL, como MongoDB, Apache Cassandra, y Redis.~\cite{mora2016serializacion}. 

\begin{figure}
  \centering
  \includegraphics[width=12cm, keepaspectratio]{img/object-json.png}
  \caption{Estructura de un objeto JSON.}\label{fig:json}
\end{figure}

\newpage

\subsection{Python} % título de sección (se muestra)
\label{sec:python} % identificador de sección (no se muestra, es para poder referenciarla)


Python\footnote{\url{https://www.python.org/}} es un lenguaje de programación de alto nivel creado por Guido van Rossum~\cite{challenger2014lenguaje} y lanzado por primera vez en 1991, cuyo nombre está inspirado en el grupo de cómicos “Monty Python”.  


Fue diseñado para facilitar la escritura de código y por tanto destaca por ser un lenguaje potente, sencillo, fácil de aprender y con una sintaxis clara y legible.
Se considera un lenguaje multiparadigma, ya que, se apoya en diferentes estilos de programación como la programación orientada a objetos, la programación funcional y la programación imperativa.   
Python además cuenta con estructuras de datos para facilitar el desarrollo de software como listas, diccionarios, conjuntos y tuplas.
También tiene una gran cantidad de bibliotecas y herramientas que facilitan el desarrollo de software; ya que, con ellas se obtienen soluciones en la tareas básicas de un programador.


Además, Python~\cite{rios2016evaluacion} cuenta con un intérprete propio y tiene compatibilidad con diferentes plataformas y sistemas operativos al ser un lenguaje de código abierto.
Esta es una de las razones de que sea utilizado en una amplia variedad de aplicaciones, como el desarrollo web, el análisis de datos, la inteligencia artificial, el aprendizaje automático, la automatización de tareas y la creación de juegos, entre otros.
Por todo esto, este lenguaje ha ganado mucha fuerza en la comunidad científica, educacional y de sofware libre.


\subsection{Ubuntu} % título de sección (se muestra)
\label{sec:ubuntu} % identificador de sección (no se muestra, es para poder referenciarla)

Ubuntu\footnote{\url{https://ubuntu.com/}} es un sistema operativo de código abierto basado en Linux diseñado con una gran cantidad de software preinstalado para satisfacer las necesidades de la mayoría de los usuarios.
Fue lanzado por primera vez en 2004 y desarrollado por una empresa llamada Canonnical~\cite{martinez2006software}, cuyo objetivo era generar un sistema fácil de instalar y utilizar, completo e innovador. 


Actualmente Ubuntu~\cite{tavera2013software} se ha convertido en uno de los sistemas operativos más populares en la comunidad de software libre y de código abierto.
Esto se debe a que está disponible de forma gratuita para su descarga y uso de múltiples formas y, además, tiene una interfaz muy parecida a Windows lo que permite que sea intuitivo y fácil de utilizar por cualquier usuario.


Al igual que con Windows, con este sistema operativo también podemos navegar en la web, crear y modificar documentos; al ser compatible con formatos de archivos muy conocidos, y otras tareas que realizamos en nuestro día a día. 
Ubuntu se utiliza en una amplia variedad de sistemas, desde ordenadores hasta servidores y dispositivos móviles. 

\subsection{WSL} % título de sección (se muestra)
\label{sec:wsl} % identificador de sección (no se muestra, es para poder referenciarla)

WSL\footnote{\url{https://learn.microsoft.com/es-es/windows/wsl/}}(Windows Subsystem for Linux) es un sistema diseñado por Microsoft que permite a los desarrolladores ejecutar aplicaciones y herramientas de línea de comandos de Linux directamente en Windows (por la capa de compatibilidad), sin necesidad de utilizar una máquina virtual o instalar un sistema operativo Linux en un disco duro. 
Este subsistema de Windows para Linux fue lanzado en 2016 y no ha dejado de evolucionar desde entonces. 


WSL~\cite{medriforensic} fue creado para los desarrolladores que necesitan utilizar herramientas y aplicaciones de línea de comandos específicas de Linux, pero prefieren trabajar en el entorno de Windows. 
También para aquellos que necesitan trabajar en los sistemas operativos Windows y Linux simultáneamente.


La versión WSL 1 utiliza una capa de compatibilidad para la transferencia de la ejecución de código entre Windows y Linux,
mientras que WSL 2 tiene una versión actualizada de su arquitectura del software con respecto a su versión anterior. 
Además, utiliza una máquina virtual de Linux integrada que ofrece un rendimiento alto y muy parecido al de un sistema Linux real.


\subsection{LaTex} % título de sección (se muestra)
\label{sec:latex} % identificador de sección (no se muestra, es para poder referenciarla)

LaTeX\footnote{\url{https://es.overleaf.com/}} es un sistema de composición de (textos)(documentos), el cual, está formado por un conjunto de macros TeX. 
Fue desarrollado por Leslie Lamport en 1984, con el fin de facilitar el uso del lenguaje de composición tipográfica de textos(documentos) TeX.
Tex, también es un sistema de composición tipográfica de textos que usa funciones avanzadas de automatización para generar documentos en los cuales se usan textos y fórmulas matemáticas con un determinado estándar.
Fue desarrollado por Donald E. Knuth en 1978 como herramienta para la creación de textos que contengan fórmulas matematicas complejas.


LaTeX~\cite{rodriguez2014edicion} usa las características del sistema TeX para generar documentos científicos, técnicos y académicos de alta calidad automaticamente, como artículos académicos, libros, tesis...   
Además, LaTeX ofrece con una variedad de paquetes, extensiones y estilos personalizados para adaptarse a las indicaciones específicas de cada usuario.
Las extensiones con las que cuenta permiten insertar fácilmente imágenes, diagramas matemáticos, fórmulas matemáticas, textos de lenguajes de programación, etc.


Estos sistemas de composición de textos están disponibles en gran cantidad de plataformas; además, cuentan con editores gratuitos que facilitan la creación de documentos sin la necesidad de tener conocimientos previos de programación.
LaTeX utiliza una sintaxis de comandos que permiten al usuario controlar la estructura y el formato del documento, incluyendo la disposición de los elementos, el estilo de las fuentes, las ecuaciones matemáticas, y las referencias bibliográficas. 


Una vez que se domina la sintaxis y las herramientas de LaTeX, se puede crear fácilmente documentos de alta calidad de manera eficiente.
Por eso LaTeX es una herramienta muy utilizada y valorada en la comunidad científica, técnica y académica se utiliza ampliamente en universidades y centros de investigación de todo el mundo por su capacidad para producir documentos de alta calidad con un aspecto profesional, incluso si se requiere un formato complejo y detallado. 


\section{Librerías} % título de sección (se muestra)
\label{sec:librerías}

\subsection{Perceval} % título de subsección (se muestra)
\label{sec:perceval} % identificador de subsección (no se muestra, es para poder referenciarla)


Perceval\footnote{\url{https://github.com/chaoss/grimoirelab-perceval}} es uno de los componentes que contiene GrimoireLAb\footnote{\url{https://chaoss.github.io/grimoirelab/}} que es uno de los proyectos fundadores de CHAOSS Software\footnote{\url{https://chaoss.community/}}.
Este proyecto fue desarrollado para ayudar a investigadores en el análisis de repositorios de software y está formado por un conjunto de herramientas gratuitas, libres y de código abierto. 


GrimoireLAb es el resultado de más de 10 años de desarrollo de Bitergia, grupo de investigación de software libre de la URJC y varios colaboradores. 
Cada herramienta se encuentra disponible en un repositorio distinto en Github y se puede instalar fácilmente como un módulo de paquetes de Python.
Dichas herramientas se crearon para la recopilación automática e incremental de información de cualquier fuente de datos, el enriquecimiento de estos con información adicional y el almacenamiento y visualización de estos datos. 


GrimoireLAb cuenta con unos componentes que se pueden usar juntos o por separado para las distintas tareas que se ejecutan en un análisis de datos.  
Perceval, como ya hemos mencionado, es uno de estos componentes que funciona como una biblioteca/módulo y proporciona una API de Python.
Está diseñado para recuperar datos relacionados con el desarrollo de software de diferentes fuentes.
Estas fuentes pueden ser de gestión de problemas o tareas, de gestión o revisión de código fuente, de foros o listas de correo, de wikis, entre otros.
Posteriormente, se guarda la información obtenida en una base de datos en un formato estandarizado.
% (Además, proporciona una interfaz de línea de comandos (CLI) y una API para interactuar con la información recopilada.)
Los datos que obtenemos con Perceval se almacenan como diccionarios de Python o como documentos JSON como el que mostramos a continuación: 

{\footnotesize
\begin{verbatim}
  {
    "backend_name": "GitHub",
    "backend_version": "0.2.2",
    "data": {
    ...
    },
    "origin": "https://github.com/grimoirelab/perceval",
    "perceval_version": "0.1.0",
    "timestamp": 1476139775.852378,
    "updated_on": 1451929343.0,
    "uuid": "c403532b196ed4020cc86d001feb091c009d3d26"
  }
\end{verbatim}
}

Esta herramienta es muy útil para desarrolladores, analistas de datos y cualquier persona interesada en la recuperación de información de diferentes fuentes de datos y su posterior análisis.
Además, cualquier persona puede participar en este proyecto aportando soluciones para corregir errores o ideas para nuevos servicios o funciones.
También, cuenta con una comunidad de desarrolladores que colaboran continuamente en el mantenimiento y la actualización de sus servicios. 

\subsection{Pymongo} % título de subsección (se muestra)
\label{sec:pymongo} % identificador de subsección (no se muestra, es para poder referenciarla)

Pymongo\footnote{\url{https://pypi.org/project/pymongo/}} es una librería de Python que contiene varias herramientas con las que podemos interactuar fácilmente desde un archivo de Python con MongoDB, siendo este una base de datos NoSQL. 
Con PyMongo, se pueden realizar una variedad de tareas en MongoDB, como crear y eliminar bases de datos y colecciones, insertar, actualizar y eliminar documentos, realizar consultas y filtrar datos, entre otras posibilidades.
% PyMongo proporciona una API completa y fácil de usar para realizar operaciones de CRUD (crear, leer, actualizar y eliminar) en MongoDB desde Python. 


\subsection{Subprocess} % título de subsección (se muestra)
\label{sec:subprocess} % identificador de subsección (no se muestra, es para poder referenciarla)
El módulo ``subprocess''\footnote{\url{https://docs.python.org/es/3/library/subprocess.html}} (subproceso), permite ejecutar un proceso que se encuentra dentro de un script de Python a la vez que se ejecuta dicho script.
Esto es posible gracias a que este módulo interactúa con el sistema operativo haciendo posible ejecutar y administrar subprocesos directamente desde Python. 
Este módulo proporciona varias funciones y clases para interactuar con procesos externos con los cuales los desarrolladores pueden ejecutar comandos en la línea de comandos del sistema operativo y manipular la entrada y salida de estos procesos.

\subsection{Mongoimpot} % título de subsección (se muestra)
\label{sec:mongoimport} % identificador de subsección (no se muestra, es para poder referenciarla)

\emph{mongoimport}\footnote{\url{https://www.mongodb.com/docs/database-tools/mongoimport/}} es una herramienta que forma parte del paquete ``MongoDB Database Tools''
Esta se utiliza para importar datos de archivos en formato JSON, CSV o TSV con facilidad desde la línea de comandos a una base de datos MongoDB. 
Con \emph{mongoimport}, se pueden importar grandes cantidades de datos de manera eficiente, además, se permite especificar la base de datos y la colección en la que se quieren almacenar.
El comando que se ha usado para importar los archivos es el siguiente:

\begin{verbatim}
mongoimport --db nombre_base_de_datos --collection nombre_coleccion --file dirección_archivo_a_importar
\end{verbatim}

\subsection{Matplotlib} % título de subsección (se muestra)
\label{sec:matplotlib} % identificador de subsección (no se muestra, es para poder referenciarla)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DISEÑO E IMPLEMENTACIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Diseño e implementación}
\label{chap:diseño}

A continuación, describiremos los métodos y herramienta utilizados para llevar a cabo el trabajo. 
Esto permite a los lectores entender cómo se ha desarrollado el proyecto para realizar el análisis de estudio.
En este capítulo se detallan las fases del proyecto, las decisiones y justificaciones de las metodologías escogidas y el diseño e implementación para que otros puedan realizar el mismo análisis.

\section{Arquitectura general} 
\label{sec:arquitectura}

En la figura~\ref{fig:arquitectura} mostraremos la arquitectura de este proyecto se divide en varias fases. 
En la primera fase se realiza la recopilación de datos de GitHub mediante la herramienta de Perceval. 
Con esta herramienta, nos conectamos a a la API de Github para extraer los datos con información de los repositorios y los commits ej documentos JSON.
En la segunda fase procesaremos estos datos antes de almacenarlos en la base de datos MongoDB, de tal forma que nos quedamos con los datos que nos interesan para el análisis que vamos a realizar y descartamos el resto de datos.
En la tercera fase realizaremos un análisis estadístico de los datos recopilados. 

el archivo JSON generado por Perceval se envía al backend para su almacenamiento y análisis posterior. El backend puede ser una base de datos, un sistema de análisis de datos o cualquier otro sistema que el usuario haya configurado para manejar la información recopilada.
\begin{figure}
  \centering
  \includegraphics[width=16cm, keepaspectratio]{img/Arquitectura_general.png}
  \caption{Descripción general de Perceval.}\label{fig:arquitectura}
\end{figure}


\section{Procedimiento de instalación} % título de sección (se muestra)
\label{sec:procedimiento de instalación}

Para poder realizar este proyecto es necesario tener intalados WSL (Windows Subsystem for Linux) en Windows y, en dicho Subsistema de Windows, tener Ubuntu como sistema operativo, además de la librería Perceval. 
A continuación, procederemos a explicar los pasos a seguir para realizar las instalaciones necesarias correctamente.

\subsection{Instalación de WSL} % título de sección (se muestra)
\label{sec:instalación de WSL}

En primer lugar, comprobaremos que nuestro ordenador cumple con los requisitos previos a la instalación, ya que para instalar WSL se necesita tener Windows 10 versión 2004 o posterior y nuestro hardware debe ser compatible con la virtualización de Hyper-V. 


Para verificar la versión de Windows, se debe abrir la Configuración y después seleccionar ``Sistema'' y, por último hacer clic en ``Acerca de''.


Para comprobar si nuestro procesador es compatible con Hyper-V debemos ir al menú de inicio de Windows y buscar ``Información del sistema''.
% Si la no está habilitado, deberás habilitarlo desde la BIOS

\begin{figure}
  \centering
  \includegraphics[width=10cm, keepaspectratio]{img/CaracteristicasWindows.PNG}
  \caption{Características de Windows.}\label{fig:CaracteristicasWindows}
\end{figure}


Si cumplimos estos requisitos, lo primero que tenemos que hacer activar los permisos para que en Windows se pueda usar WSL.
Para habilitar los permisos para usar WSL en Windows debemos seguir los siguientes pasos:
\begin{enumerate}
  \item Ir al menú de inicio de Windows y buscar ``Activar o desactivar las características de Windows''.
  \item Marcar la casilla de verificación de ``Subsistema de Windows para Linux'' como podemos observar en la figura~\ref{fig:CaracteristicasWindows}.
  \item Hacer clic en ``Aceptar'' y esperar a que finalice el proceso. 
  \item Por último, reiniciar el ordenador para completar la instalación.
\end{enumerate} 
  

Una vez que nos aseguremos de cumplir estos requisitos y tener habilitado WSL en el ordenador procedemos a instalar la distribución de Linux (Ubuntu) desde la Microsoft Store para usar en WSL. 

\subsection{Instalación de Ubuntu} % título de sección (se muestra)
\label{sec:instalación de ubuntu}

A continuación, descargaremos la versión de GNU/Linux que queramos usar; en nuestro caso hemos descargado la versión Ubuntu 20.04.5 LTS.


Desde la propia tienda de aplicaciones de Windows buscar ``Ubuntu'', debemos seleccionar la versión deseada y hacer clic en ``Obtener'', como mostramos en la figura~\ref{fig:ubuntu}.
Cuando se ha descargado podremos comprobar que Ubuntu se ejecuta con WSL.

\begin{figure}
  \centering
  \includegraphics[width=10cm, keepaspectratio]{img/Ubuntu.PNG}
  \caption{Características de Windows.}\label{fig:ubuntu}
\end{figure}

\subsection{Instalación de Perceval} % título de sección (se muestra)
\label{sec:instalación de perceval}

Antes de instalar Perceval tenemos que conectarnos al Subsistema de Windows para Linux ya que instalaremos dicha librería en este entorno.
A continuación, para acceder a WSL abriremos Visual Studio Code e instalaremos la extensión WSL que vemos en la figura~\ref{fig:extensionwsl}, que permite obtener toda la productividad de Windows mientras se trabaja con las herramientas y utilidades basadas en Linux.
Con esta extensión se puede utilizar VS Code en WSL tal y como se haría desde Windows.

\begin{figure}
  \centering
  \includegraphics[width=14cm, keepaspectratio]{img/extension_wsl.PNG}
  \caption{Estencion WSL de Visual Studio Code.}\label{fig:estensionwsl}
\end{figure}

Una vez estemos conectados a WSL, pasamos a realizar los siguientes pasos para instalar Perceval en Ubuntu:
\begin{enumerate}
  \item Instalar la última versión de Python y Pip, si aún no se tiene instalada en el sistema.
  \item Instalar las dependencias requeridas para GrimoireLab Perceval utilizando el siguiente comando: \emph{pip install perceval}
\end{enumerate}

Para verificar que la instalación se ha completado con éxito usaremos el comando: \emph{perceval --version} 
Si este comando devuelve la versión de GrimoireLab Perceval instalada, entonces la instalación se ha completado correctamente y se puede empezar a utilizar Perceval para recopilar datos de diversas fuentes de software.

\section{Recopilación de datos} % título de sección (se muestra)
\label{sec:recopilación de datos}

En esta parte del proyecto se lleva a cabo la recopilación de una lista de repositorios que utilizan archivos UML y otra en las que no se utilizan archivos UML.
Para ello se recurre a Lindholmen dataset que proporciona a los investigadores listas de proyectos de código abierto que usan archivos UML y que se encuentran distribuidos en repositorios de GitHub.

A partir de este conjunto de datos se descarga el archivo ``UMLFilesList'' para obtener una lista de los repositorios que hacen uso de archivos UML.
Este archivo proporciona los enlaces directos a los archivos UML de cada uno de los repositorios, lo que permite verificar que dichos archivos siguen formando parte de dichos repositorios.
Con estos enlaces nos cercioramos de que los archivos continuen, cada uno de ellos, siendo parte de los diferentes proyectos, los cuales posteriormente procederemos a analizar. 


Para obtener la lista de repositorios en los que no se usen archivos UML se procede a revisar los seguidores de los repositorios obtenidos anteriormente y se selecionan de forma aleatoria algunos de ellos para crear dicha lista.


Una vez que se obtienen ambas listas de repositorios, se procede a descargar los datos de los mismos, así como los de los commits, empleando la herramienta Grimoire Perceval.
Esta herramienta soporta más de 30 fuentes de datos de los cuales se pueden obtener datos.
En la figura \ref{fig:perceval-json} vemos un esquema del procedimiento que sigue Perceval. 
En éste, el cliente escoge la fuente de la cual desea obtener los datos a analizar y ejecuta Perceval desde la línea de comandos con los parámetros necesarios para recopilar la información de la fuente seleccionada.
Posteriormente, Perceval procesa esta información y la almacena en documentos. 

\begin{figure}
  \centering
  \includegraphics[width=10cm, keepaspectratio]{img/perceval-json.png}
  \caption{Descripción general de Perceval.}\label{fig:perceval-json}
\end{figure}

En este proyecto se eligió como fuente de datos Github. 
Partiendo de esta fuente de datos a Perceval se le pasaron los siguientes parámetros: el nombre del repositorio o dirección URL, el nombre y tipo de archivo con el que queremos que se guarden los documentos generados y, además, según el comando usado obtendremos los datos de los repositorios o de otras categorías como, en este caso, los commits, u otras como las issues, los pull request...
\begin{verbatim}
perceval github --category repository grimoirelab Perceval > repo.json
perceval git https://github.com/grimoirelab/perceval.git > commit.json
\end{verbatim} 
    

Gracias a esta herramienta, se pudo obtener información detallada de los repositorios y los commits, lo que resultó fundamental para el desarrollo de este proyecto de investigación.
Estos datos se guardaron en archivos JSON, puesto que es una estructura de datos ampliamente utilizada y fácil de comprender.
Para llevar a cabo esta tarea usamos una conexion WLS en la cual se instaló tanto Ubuntu como la librería de Perceval; ya que en Windows daba problemas.
La intalación tanto de WLS como de Ubuntu y Perceval se han explicado en el apartado \ref{sec:procedimiento de instalación}.

Después de finalizar el proceso de obtención de los datos de los repositorios se procedió a almacenarlos en la base de datos MongoDB.
Para este fin, se buscó una forma de introducir los archivos JSON de forma automática. 
Para ello, se uso el módulo de python \emph{subprocess} junto con \emph{mongoimport} para desarrollar los ficheros que introducen todos los documentos JSON, obtenidos anteriormente, para crear la base de datos que vamos a estudiar.
En estos fichero se ejecuta \emph{mongoimport} con cada uno de los archivos JSON obtenidos, tanto de los de los repositorios como de los commits con el comando que se muestra a continuación:
\begin{verbatim}
  mongoimport --db project --collection Repositories --file "...\repository\repoFile.json"
  mongoimport --db project --collection Commits --file "...\commit\commitFile.json"
\end{verbatim}


en el cual;
\begin{itemize}
  \item ``Project'' es el nombre de nuestra base de datos
  \item ``Repositories'' es el nombre de la colección en la que almacenaremos todos los datos extraídos de cada repositorio.
  \item ``Commits'' es el nombre de la colección en la que almacenaremos todos los datos extraídos de cada commit hecho por cada repositorio.
  \item ``...\textbackslash repository\textbackslash repoFile.json'' es la ruta en la que se encuentran todos los archivos JSON que se corresponden con los datos extraídos de los repositorios.
  \item  ``...\textbackslash commit\textbackslash commitFile.json'' es la ruta en la que se han almacenado los archivos JSON con los datos de los commits generados por los repositorios
\end{itemize}

\section{Procesado de datos} % título de sección (se muestra)
\label{sec:procesado de datos}

Después de almacenar todos los archivos JSON de la lista de respositorios seleccionados, empezamos a observar los datos obtenidos y se eligieron los más adecuados para analizar los tipos de desarrolladores seleccionados. 
Posteriormente, se inició el desarrollo de varios ficheros con los que extaer los datos de mayor interés. 
Al mismo tiempo, se estudió en qué tipo de base de datos se deberían guardar los archivos JSON obtenidos con Perceval.
Se optó por una base de datos que no fuese relacional (NoSQL), ya que los datos no estaban relacionados entre sí y este tipo de bases de datos son muy útiles para trabajar con grandes conjuntos de datos distribuidos.
Por esta razón, se decidió almacenarlos en MongoDB que es una base de datos NoSQL de código abierto. 

\begin{figure}
  \centering
  \includegraphics[width=16cm, keepaspectratio]{img/procesamiento_datos.png}
  \caption{Descripción de la fase de procesamiento de datos.}\label{fig:procesamiento_datos}
\end{figure}

Para almacenar estos datos se desarrolló un fichero que se conecta a MongoDB y, a partir de aquí, se crea una nueva coleción y se introducen los datos que le pasamos.
A la hora de importar los datos se decidió usar una estructura de diccionario como la que obsevamos a continuación.

{\footnotesize
\begin{verbatim}
  {
  "_id": { <ObjectId>},
  "Desarrollador": String,
  "Origin": String,
  "Owners": String,
  "Repositories": String,
  "Language": String,
  "License": Mixted,
  "TypeDeveloper": String,
  "Fork": Int32,
  "Commit": Int32
  }
\end{verbatim}
}


A continuación, se explicaran los datos extraídos de los repositorios y los commits que se han guardado en esta estructura:
\begin{itemize}
  \item Desarrollador: en este campo se indica si en dicho repositorio se usan archivos UML o no.
  Por tanto, los valores de este campo pueden ser ``UML'', si en el proyecto existen archivos de este tipo, o ``NOUML'', si en el proyecto no existen archivos UML.
  
  \item Origin: se refiere a la ubicación del repositorio.
  Esta información se usa cuando un usuario quiere clonar un repositorio de Github.
  
  \item Owners: en este campo se muestra el nombre del propietario del repositorio. 
  Es decir, el usuario o la organización que creó el repositorio y que es responsable de los cambios que se producen en él. 
  Con este campo se puede acceder a otros repositorios que sean propiedad del mismo usuario u organización. 
  Además, también, se puede utilizar para identificar el perfil de GitHub del propietario del repositorio y ponerse en contacto con él.
  
  \item Repositories: nos muestra el nombre completo del repositorio, es decir, incluye tanto el nombre del usuario u organización, como el nombre del repositorio en sí, separados por una barra diagonal (/).
  Esta información nos sirve para identificar el repositorio al que pertenece la información extraída.

  \item Language: nos muestra el lenguaje de programación principal utilizado en el repositorio.
  Los valores pueden ser, por ejemplo, ``Python'', ``Java'', ``JavaScript'', ``C++'', ``Ruby'', entre otros.
  
  \item License: en este campo se muestra la licencia bajo la cual está disponible el código fuente del proyecto.
  Para que un repositorio sea verdaderamente de código abierto, tendrá que generarse una licencia. 
  Con esta licencia cada propietario define el marco legal en el que se puede usar, distribuir o modificar el proyecto.
  Algunas licencias pueden ser más restrictivas que otras en cuanto a los derechos que otorgan a los usuarios y desarrolladores de software.
  
  \item TypeDeveloper: se indica si el repositorio en cuestión pertenece a un usuario individual o a una organización. 
  Los valores pueden ser ``User'', si el propietario del repositorio es un usuario individual, o ``Organization'', si el propietario del repositorio es una organización y no un usuario individual. 
  Las organizaciones en GitHub están formadas por grupos de personas que trabajan juntas en un proyecto o en varios proyectos relacionados.
  
  \item Fork: se indica si ese repositorio es una copia de otro repositorio existente en GitHub. 
  Los valores de este campo pueden ser ``true'', que significa que el repositorio es una bifurcación o ``fork'' de otro repositorio en GitHub o ``false'', que significa que el repositorio no es una copia de ningún otro repositorio de Github.
  Los usuarios de GitHub utilizan los ``fork'' para crear nuevas versiones de un proyecto existente para agregar nuevas funcionalidades, corregir errores, o personalizar un proyecto original.
  Cada vez que se crea un ``fork'', se crea una copia completa del repositorio original en el que se pueden realizar cambios sin afectar al repositorio original.
  
  \item Commit: se muestra el número de commits qua se han realizado en el repositorio.
  Un ``commit'' es una acción que se realiza para guardar los cambios realizados en los archivos de un repositorio.
  Todos estos ``commits'' se guardan en el historial del repositorio, por tanto, esto permite a los usuarios tener la posibilidad de revisar las modificaciones realizadas y revertir cambios en caso de ser necesario. 
  Por lo tanto, el número de commits nos puede indicar el nivel de actividad de un proyecto, así como la frecuencia de actualizaciones, mejoras y mantenimiento del mismo.
  
\end{itemize} 

\section{Análisis de datos} % título de sección (se muestra)
\label{sec:análisis de datos}

Con el análisis de datos, que es el objetivo final del proyecto, se pretende conocer las similitudes y diferencias entre los desarrolladores que utilizan archivos UML y el resto de los desarrolladores que no utilizan este tipo de archivos.


En esta sección se describe el proceso de análisis de los datos obtenidos, a partir de Perceval, de los distintos repositorios de Github. 
Se comenzó por la revisión y limpieza de los datos, eliminando aquellos que decidimos no incluir, ya que no se consideraban datos relevantes para el análisis que pretendemos hacer. 
A partir de aquí, se procedió a la exploración de los datos, mediante el cálculo de estadísticos descriptivos, para cada una de las variables de interés. 
Para ello se realizó un fichero en el que se ejecuta el análisis de los datos extraídos usando Python, observando así las diferencias entre los desarrolladores que utilizan UML y el resto.
A este fichero se le pasaron los 400 datos recogidos; de los cuales, la mitad son desarrolladores que usan archivos UML y la otra mitad desarrolladores que no usan archivo UML. 
En el fichero desarrollado se han analizado los siguientes datos de cada uno de los repositorios:

\subsection{Licencia del repositorio} % título de subsección (se muestra)
\label{sec:licencia del repositorio}
Lo primero que nos interesa conocer es el número de archivos que tienen licencia y cuáles no.
Para ello se realiza un proceso de análisis estadístico de los repositorios para saber si tienen o no licencia.
Para cada repositorio, se ha accedido al valor ``Licencia'' de los documentos JSON obtenidos con Perceval y se ha registrado la información correspondiente.

En este análisis lo primero será extraer cada uno de los documentos JSON, que hemos generado, para guardar los puntos a analizar de cada desarrollador.
De cada uno de estos documentos se obtendrán los valores almacenados en el campo ``Licencia''.
Posteriormente, se comprobará si el objeto JSON tiene información en el valor ``Licencia''; si el valor es nulo, se entiende que el repositorio no tiene licencia.


\begin{equation}
  Licencia =
  \begin{cases}
  [licencia], & \text{si el repositorio tiene una licencia} \\
  null, & \text{si el repositorio no tiene una licencia}
  \end{cases}
\end{equation}

Después de recoger los resultados de esta función comparativa, se procede a realizar la media de los 200 repositorios con archivos UML y la media de los 200 que no tienen este tipo de archivos.
\[{Licencia} = \frac{1}{200} \sum_{i=1}^{200} x_i\]

\subsection{Propietario del repositorio} % título de subsección (se muestra)
\label{sec:propietario del repositorio}

Otro de los datos relevantes que nos interesa conocer es el tipo de propietario de los repositorios, si usuario único o bien un usuario que es una organización. 
Para ello se procede a estudiar el promedio de los tipos de propietarios de los desarrolladores UML y del resto de los desarrolladores.
Los posibles tipos de propietarios que puede haber son ``User'', si es un usuario único o ``Organization'' si se trata de una organización compuesta por varios usuarios.
Esta información se muestra también en los documentos JSON obtenidos de los repositorios.

\begin{equation}
  Propietario =
  \begin{cases}
  User, & \text{si el propietario del repositorio es un usuario} \\
  Organization, & \text{si el propietario del repositorio es una organización}
  \end{cases}
\end{equation}

Después de haber definido los propietarios de cada uno de los repositorios, se realizará la media de todos ellos para conocer si los repositorios que contienen archivos UML suelen ser propiedad de organizaciones o de usuarios únicos.
A continuación se muestra la fórmula usada para realizar las medias de los repositorios cuyos propietarios son usuario o desarrolladores:

\[{User} = \frac{1}{200} \sum_{i=1}^{200} x_i\]
\[{Organization} = \frac{1}{200} \sum_{i=1}^{200} x_i\]


\subsection{Existencia de fork del repositorio} % título de subsección (se muestra)
\label{sec:existencia de fork del repositorio}

Un tercer tipo de dato que nos interesa en este análisis es saber si se han hecho bifurcaciones de los respositorios.
Para obtener dicha información se usará la función, que indicamos más adelante, que nos permitirá comprobar si en los repositorios, que se han seleccionado, se han realizado fork o no.
En los datos extraídos con Perceval de los repositorios se encuentra el campo ``Fork'' con el cual se comprueba si se ha realizado una bifurcación (``Fork'') del proyecto o no.
En caso de que el valor de este campo sea ``true'' , se habrá realizado el ``Fork''; en caso contrario, este valor será ``false''.


\begin{equation}
  Fork =
  \begin{cases}
  True, & \text{si en el repositorio se ha hecho un fork} \\
  False, & \text{si en el repositorio no se ha hecho un fork}
  \end{cases}
\end{equation}

Una vez que se han definido los repositorios que tiene fork y los que no, se procederá a realizar la media de todos ellos para conocer si los desarrolladores UML suele realizar fork con respecto al resto de los desarrolladores.
A continuación se muestra la fórmula usada para realizar la media de los repositorios que han realizado un fork:


\[{Fork} = \frac{1}{200} \sum_{i=1}^{200} x_i\]

\subsection{Lenguaje de programación principal del repositorio} % título de subsección (se muestra)
\label{sec:lenguaje de programación principal del repositorio}
Para comprobar los lenguajes de programación que predominan, según si el desarrollador utiliza archivos UML o no, se han recogido todos ellos en los documentos JSON generados.
Con esta información se realizará la media de estos datos siguiendo la siguiente fórmula para cada uno de los 10 lenguajes de programación que se han seleccionado.


\[{Lenguaje X} = \frac{1}{200} \sum_{i=1}^{200} x_i\]

\subsection{Cantidad total o frecuencia de los commits del repositorio} % título de subsección (se muestra)
\label{sec:cantidad total o frecuencia de los commits del del repositorio}

Otro dato a analizar es el número total de commits que ha realizado el propietario de los repositorios.
Este dato representa la cantidad de cambios o actualizaciones que se han realizado en el código del proyecto.
Lo que nos puede dar una idea de si el desarrollador ha dedicado una gran cantidad de tiempo en un proyecto o no y, por tanto, esto nos dice si el proyecto en sí es grande o no. 

Para saber el número medio de commits que realizan los desarrolladores que usan archivos UML y los que no los usan, se usará la fórmula de la media como se ha hecho en los casos anteriores.
Con esta fórmula usaremos los datos relacionados con el número total de commits de cada repositorio que se encuantran almacenados en los documentos JSON de la base de datos de MongoDB.
Estos documentos JSON los analizaremos separando los repositorios con UML del resto. 
Por tanto, se realizarán dos medias de 200 datos cada una de ellas, para comparar el número medio de commits que realiza cada tipo de desarrollador.
\[{Commits} = \frac{1}{200} \sum_{i=1}^{200} x_i\]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% EXPERIMENTOS Y VALIDACIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Experimentos y validación}
\label{chap:experimentos}
Este capítulo se introdujo como requisito en 2019. 
Describe los experimentos y casos de test que tuviste que implementar para validar tus resultados. 
Incluye también los resultados de validación que permiten afirmar que tus resultados son correctos. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RESULTADOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Resultados}
\label{chap:resultados}

En este capítulo se incluyen los resultados de tu trabajo fin de grado. 
Si es una herramienta de análisis lo que has realizado, aquí puedes poner ejemplos de haberla utilizado para que se vea su utilidad.

\section{Descripción de los datos recopilados}
\label{sec:descripción de los datos recopilado}

Los datos recopilados para el análisis de este proyecto se obtuvieron de una selección de repositorios públicos almacenados en GitHub. 
Estos repositorios pueden contener archivos de código, documentación y otros tipos de archivos como los ``.uml''.
Este último tipo de archivos será el que divida los datos obtenidos para el análisis de nuestro estudio en los repositorios que lo contengan y en los que no.


Para la selección de los 400 repositorios que se han analizado en este proyecto, se han escogido 200 repositorios con archivos ``.uml'', los cuales han sido obtenidos de la base de datos Lindholmen dataset\footnote{\url{http://models-db.com/}}, que contiene una lista con los repositorios que utilizan diagramas UML en GitHub.


En cuanto a los repositorios que no contienen archivos ``.uml'', estos se han recopilado manualmente de los usuarios que siguen o son colaboradores de los usuarios que aparecen en la lista de los repositorios con archivos ``.uml''.


Para reunir los datos que se usarán en el análisis del proyecto, se ha recurrido a la herramienta de Perceval, con la cual se han obtenido 400 archivos en formato JSON con todos los datos de cada repositorio de GitHub y otros 400 archivos JSON con los commits generados en estos repositorios.
Estos archivos JSON contienen datos estructurados de toda la información de los repositorios a analizar, lo que nos permitirá organizar y almacenar los datos de interés de cada uno de estos archivos fácilmente. 


Como se ha mencionado anteriormente, el conjunto de los 400 archivos JSON, tanto de los repositorios como de los commits, se ha dividido en aquellos repositorios que usan ``.uml'' y aquellos que no. 
Con esta división de los datos contenidos en los archivos JSON, se analizarán mejor las similitudes y diferencias entre los diferentes ususarios de estos repositorios. 


De las características que se pueden observar en cada uno de los archivos JSON, obtenidos tanto de los repositorios como de los commits realizados en estos, se han decidido estudiar las siguientes: la licencia ( nos dice si el repositorio garantiza derechos y responsabilidades),
el tipo de propietario ( nos dice si el propietario del repositorio es un usuario único o una entidad que representa un grupo de personas ), la existencia de forks (nos dice si el repositorio permite a colaboradores trabajar directamente en el repositorio o trabajar en una copia independiente de este ),
el lenguaje de programación principal ( nos dice el lenguaje principal que se emplea en el repositorio ), la cantidad total o frecuencia de los commits ( refleja el nivel de actividad de un proyecto).
Para extraer dichas características de los archivos JSON, se ha realizado un procesamiento de los datos que se encuentran en estos archivos.
Con el objetivo de obtener los datos de estas características se han desarrollado varios ficheros de Python con los cuales se sacan los datos que se encuentran en diferentes campos de los archivos JSON.

\begin{figure}
  \centering
  \includegraphics[width=12cm, keepaspectratio]{img/Figure_repos.png}
  \caption{Número de repositorios con archivos UML y sin archivos UML.}\label{fig:Figure_repos}
\end{figure}

\section{Análisis estadístico de los datos recopilados}
\label{sec:análisis descriptivo de los datos recopilado}

Después de recopilar y preprocesar los datos seleccionados se realiza un análisis estadístico de estos con el cuál se podrán observar las similitudes y diferencias de los desarrolladores que se han seleccionado en este estudio.


\section{Interpretación de los resultados del análisis}
\label{sec:interpretación de los resultados del análisis}

\begin{figure}
  \centering
  \includegraphics[width=12cm, keepaspectratio]{img/Figure_license.png}
  \caption{Número de repositorios con licencia y sin licencia.}\label{fig:Figure_license}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=12cm, keepaspectratio]{img/Figure_typeDeveloper.png}
  \caption{Número de propietarios que son ususarios y organizaciones.}\label{fig:Figure_typeDeveloper}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=12cm, keepaspectratio]{img/Figure_fork.png}
  \caption{Número de repositorios con fork y sin fork}\label{fig:Figure_fork}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=12cm, keepaspectratio]{img/Figure_commits.png}
  \caption{Número de commits total}\label{fig:Figure_commits}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=12cm, keepaspectratio]{img/Figure_languages.png}
  \caption{Número de repositorios por lenguaje principal de programación}\label{fig:Figure_language}
\end{figure}


\section{Conclusiones de los resultados del análisis}
\label{sec:conclusiones de los resultados del análisis}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONCLUSIONES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Conclusiones}
\label{chap:conclusiones}


\section{Consecución de objetivos}
\label{sec:consecucion-objetivos}

Esta sección es la sección espejo de las dos primeras del capítulo de objetivos, donde se planteaba el objetivo general y se elaboraban los específicos.

Es aquí donde hay que debatir qué se ha conseguido y qué no. 
Cuando algo no se ha conseguido, se ha de justificar, en términos de qué problemas se han encontrado y qué medidas se han tomado para mitigar esos problemas.

Y si has llegado hasta aquí, siempre es bueno pasarle el corrector ortográfico, que las erratas quedan fatal en la memoria final.
Para eso, en Linux tenemos aspell, que se ejecuta de la siguiente manera desde la línea de \emph{shell}:


\begin{verbatim}
  aspell --lang=es_ES -c memoria.tex
\end{verbatim}

\section{Aplicación de lo aprendido}
\label{sec:aplicacion}

La aplicación de los conocimientos y habilidades adquiridos en mi formación académica en el Grado en Ingeniría en Sistemas Audiovisuales y Multimedia ha sido esencial para la elaboración de este Trabajo de Fin de Grado.
A continuación, se mencionan los aprendizajes que me permitieron realizar la extracción, tratamiento y clasificación de datos para obtener como resultado el análisis de este proyecto. 

\begin{enumerate}
  \item Informática I: Me sirvió fundamentalmente par adquirir las bases de programación.
  \item Informática II: Aparte de reforzar las bases de programación adquiridas, obtuve una formación en otras herramientas comúnmente usadas para programar y, además, mejoré la estructuración de código y lógica necesarias en programación.
  \item Protocolos para la Transmisión de Audio y Vídeo de Internet: En esta materia aprendí los conocimientos del lenguaje de programación Python además de cómo se estructura y para qué se usa la estructura de datos JSON.
\end{enumerate}


\section{Lecciones aprendidas}
\label{sec:lecciones_aprendidas}

Durante la realización de este Trabajo de Fin de Grado, he adquirido diversos conocimientos sobre las herramientas usadas para realizar un análisis de datos. 
A continuación, se presentan algunos de los aprendizajes más significativos que he adquirido:

\begin{enumerate}
  \item  Al inicio de este proyecto lo primero que aprendí fue cómo funciona la herramienta de Perceval. Gracias a ella he podido obtener los datos necesarios para realizar el análisis de este proyecto, que era el objetivo final del mismo. 
  \item  Este proyecto, además, me ha servido para entender mejor los tipos de repositorios que se encuentran en GitHub; ya que, analizando las características de estos repositorios se puede sacar mucha información de sus propietarios para ver las características que los definen, tales como si usan licencia, si son usuarios únicos o forman parte de una organización, etc.
  \item  He ampliado mis conocimientos sobre la estructura JSON. Esto me ha servido para comprender porque es comúnmente utilizada para el tratamiento e intercambio de datos, la razón no es otra que su sintaxis sencilla, su formato ligero y su flexibilidad en la estrutura de datos. Además, como he trabajado con archivos JSON durante la realización del proyecto, he mejorado la forma en la que tratar dichos archivos a la hora de extraer y guardar datos en dicha estructura.  
  \item  También, he mejorado mis conocimientos de Python al emplear este lenguaje de programación en el desarrollo de los ficheros que se han usado para el tratamiento de los datos de los archivos JSON obtenidos con Perceval.    
  \item  Utilizar MongoDB ha sido otro de los aprendizajes durante este proyecto; puesto que, no tenía apenas conocimientos de bases de datos y nunca las había utilizado. Asimismo, en este proyecto, he aprendido a usar MongoDB con Python empleando el módulo ``pymongo'' con el que te puedes contectar a MongoDB y trabajar con las bases de datos.
  \item  Aprender a usar el módulo ``subprocess'' ha sido muy útil; puesto que con este módulo se ha creado un fichero, que introduce todos los documentos JSON en MongoDB, de modo automático al ejecutar dicho fichero.
  \item  Realizar este proyecto con LaTeX ha sido otra de las lecciones que he adquirido. El aprendizaje de Latex no ha sido muy costoso y gracias a él he podido tener la memoria del Trabajo de Fin de Grado bien estructurada y organizada.
\end{enumerate}


Entre las lecciones aprendidas detacaría también la adquisición o mejora de algunas destreza necesarias para elaborar un proyecto de estas características:
\begin{enumerate}
  \item  La primera es que este proyecto me ha servido para saber determinar y acotar el objeto de investigación de un proyecto como éste y los pasos a seguir en su desarrollo.
  \item  La planificación y la capacidad para establecer plazos realistas sobre las diferentes etapas del proyecto ha sido otra destreza que he mejorado durante la realización de este Trabajo de Fin de Grado.
  \item  Otra de las destrezas que he desarrollado es a saber elegir y seleccionar qué información, entre la gran cantidad de información que exite, es relevante y cual no, puesto que no aporta nada significativo al objeto de investigación.
  \item  También he adquirido la aptitud para resolver y analizar los problemas que pueden surgir en un proyecto de este tipo y buscar posibles soluciones y alternativas.  
  \item  Y, por último, el esfuerzo de síntesis a la hora de redactar el proyecto y que este resulte claro para aquellos que lo lean y quieran realizar o ampliar dicho estudio. 
\end{enumerate}

\section{Trabajos futuros}
\label{sec:trabajos_futuros}

Ningún proyecto ni software se termina, así que aquí vienen ideas y funcionalidades que estaría bien tener implementadas en el futuro.

Es un apartado que sirve para dar ideas de cara a futuros TFGs/TFMs.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APÉNDICE(S) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \cleardoublepage
% \appendix
% \chapter{Manual de usuario}
% \label{app:manual}

% Esto es un apéndice.
% Si has creado una aplicación, siempre viene bien tener un manual de usuario.
% Pues ponlo aquí.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
% \chapter*{Bibliografía}
% \label{app:bibliografía}

% Las siguientes dos instrucciones es todo lo que necesitas
% para incluir las citas en la memoria
\bibliographystyle{abbrv}
\bibliography{memoriaTFG}  % memoria.bib es el nombre del fichero que contiene


% las referencias bibliográficas. Abre ese fichero y mira el formato que tiene,
% que se conoce como BibTeX. Hay muchos sitios que exportan referencias en
% formato BibTeX. Prueba a buscar en http://scholar.google.com por referencias
% y verás que lo puedes hacer de manera sencilla.
% Más información: 
% http://texblog.org/2014/04/22/using-google-scholar-to-download-bibtex-citations/

\end{document}